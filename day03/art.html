<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ART</title>
</head>
<body>
<style>
    * {
        margin: 0;
        padding: 0;
    }
    body {
        background-color: gray;
        text-align: center;
    }
    svg {
        background-color: white;
    }
    button {
        position: fixed;
        font-size: 32px;
        width: 48px;
        height: 48px;
        right: 12px;
        top: 12px;
        background-color: #ffffff88;
        border: 2px solid white;
        border-radius: 99em;
        cursor: pointer;
    }
    button:hover {
        background-color: #fff;
    }
</style>
<svg></svg>
<button onclick="download();">↓</button>
<script>
    const paper = "black";
    let pen = "white";  // can be changed later

    // in mm
    const stroke = 0.4;
    const w = 160;
    const h = 100;

    // adjustment knob
    const scale = 1.13;

    ////////////////////////////////////////////////////////////////////////////

    // really bad but interesting: shape depends on multiplier, seed picks a "starting node"
    let seed = 1;
    const rand = (n) => 98717 * Math.abs(Math.sin(seed++ * 103291 + n * seed * 20389)) % 1;

    // based on https://stackoverflow.com/a/16245768
    function htmlToObjectURL(html) {
        const sliceSize = 512;
        const byteArrays = [];

        for (let offset = 0; offset < html.length; offset += sliceSize) {
            const slice = html.slice(offset, offset + sliceSize);

            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }

            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }

        const blob = new Blob(byteArrays, {type: 'text/html'});
        const url = URL.createObjectURL(blob)
        return url;
    }

    function downloadFile(hrefData, filename) {
        let a = document.createElement("a");
        a.href = hrefData;
        a.setAttribute("download", filename);
        document.body.appendChild(a);
        a.click();
        a.outerHTML = "";
    }

    function download() {
        let filename = "art_seed" + seed + "_" + new Date().toISOString().replace(/\:/g, ".");
        downloadFile(htmlToObjectURL(svg.outerHTML), filename + ".svg");
    }

    const svg = document.querySelector("svg");
    svg.style.strokeWidth = stroke;
    svg.style.fill = "none";
    svg.setAttribute("width", `${w}mm`);
    svg.setAttribute("height", `${h}mm`);
    svg.style.width = `${w * scale}mm`;
    svg.style.height = `${h * scale}mm`;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("xmlns:inkscape", "http://www.inkscape.org/namespaces/inkscape");
    svg.innerHTML = `<rect width="100%" height="100%" fill="${paper}"/>`

    let path = [];

    let layerNum = 1;

    const draw = (continueFromSameSpot) => {
        const ePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        ePath.setAttribute("d", path.map(c => c.join(" ")).join(" "));
        ePath.style.stroke = pen;

        // append to exisiting color layer if exists, create a new one otherwise
        // note: layers are an inkscape thing, helps with color separation when
        //       plotting using the inkscape axidraw extension
        let layer = svg.querySelector(`g.${pen}`);
        if (layer != null) {
            layer.appendChild(ePath);
        } else {
            layer = document.createElementNS("http://www.w3.org/2000/svg", "g");
            layer.setAttribute("class", pen);
            layer.setAttribute("inkscape:groupmode", "layer");
            layer.setAttribute("inkscape:label", `${layerNum} ${pen}`);
            layer.setAttribute("inkscape:groupmode", `layer`);
            layer.setAttribute("id", `layer${layerNum}`);
            layerNum++;

            layer.appendChild(ePath);
            svg.appendChild(layer);
        }

        if (continueFromSameSpot) {
            path = [["M", path[path.length - 1][1], path[path.length - 1][2]]];
        } else {
            path = [];
        }
    };

    const m = (x, y) => path.push(["M", x, y]);
    const l = (x, y) => path.push(["L", x, y]);

    // out-of-place rotation of p = [x₁,y₁] around o = [x₂,y₂], based on
    // http://stackoverflow.com/a/2259502
    const rotate = (o, p, angle) => {
        var s = Math.sin(angle);
        var c = Math.cos(angle);

        // copy point
        p = [p[0],p[1]];

        // translate point back to origin
        p[0] -= o[0];
        p[1] -= o[1];

        // rotate point
        var xnew = p[0] * c - p[1] * s;
        var ynew = p[0] * s + p[1] * c;

        // translate point back:
        p[0] = xnew + o[0];
        p[1] = ynew + o[1];

        return p;
    };

    const spiral = (center, r) => {
        const segmentsPerRotation = 100;
        const offsetPerSegment = stroke / segmentsPerRotation;

        m(center[0], center[1]);
        let currentAngle = 0;
        let currentRadius = 0;
        while (currentRadius < r) {
            let x = Math.cos(currentAngle) * currentRadius;
            let y = Math.sin(currentAngle) * currentRadius;

            l(center[0] + x, center[1] + y);

            currentAngle += 2 * Math.PI / segmentsPerRotation;
            currentRadius += offsetPerSegment;
        }

        // finish one more turn as circle
        for (let i = 0; i < segmentsPerRotation; i++) {
            let x = Math.cos(currentAngle) * currentRadius;
            let y = Math.sin(currentAngle) * currentRadius;

            l(center[0] + x, center[1] + y);

            currentAngle += 2 * Math.PI / segmentsPerRotation;
        }
    };

    // two passes because gel pens often take a second to begin drawing (and
    // might not be fully opaque with a single pass)
    const spiral2 = (center, r) => {
        spiral(center, r);
        spiral(center, r);
    }

    const circle = (center, r) => {
        const segments = 100;

        m(center[0] + r, center[1]);

        for (let i = 0; i < segments + 1; i++) {
            let angle = 2 * Math.PI * (i / segments);

            let x = Math.cos(angle) * r;
            let y = Math.sin(angle) * r;

            l(center[0] + x, center[1] + y);
        }
    }

    // TODO do something with this, vary factor in Math.cos(angle * 3)
    /*const ellipse = (center, rMin, rMax) => {
        const segments = 100;

        m(center[0] + rMax, center[1]);

        for (let i = 0; i < segments + 1; i++) {
            let angle = 2 * Math.PI * (i / segments);
            let r = rMin + (rMax - rMin) * (0.5 + Math.cos(angle * 3) / 2);

            let x = Math.cos(angle) * r;
            let y = Math.sin(angle) * r;

            l(center[0] + x, center[1] + y);
        }
    };*/

    const fakeEllipse = (center, rMin, rMax) => {
        const segments = 100;

        m(center[0] + rMax, center[1]);

        for (let i = 0; i < segments + 1; i++) {
            let angle = 2 * Math.PI * (i / segments);
            let r = rMin + (rMax - rMin) * (0.5 + Math.cos(angle * 2) / 2);

            let x = Math.cos(angle) * r;
            let y = Math.sin(angle) * r;

            l(center[0] + x, center[1] + y);
        }
    };

    ////////////////////////////////////////////////////////////////////////////

    seed = 56787654;

    // stars
    for (let i = 0; i < 50 + rand(0) * 100; i++) {
        let x = rand(i) * w;
        let y = rand(i) * h;

        pen = "white";

        // one pass is enough here, hence not "spiral2"
        spiral([x, y], h/500 + rand(i) * h/300);
        draw();
    }

    // sun – one or two
    pen = "yellow";
    if (rand(0) < 0.8) {
        spiral2([w/2,h/2], h/(10 + rand(0) * 20));
        draw();
    } else {
        const rotation = 2 * Math.PI * rand(0);
        const totalSize = 30 + rand(0) * 20;
        const sun1Size = (0.3 + 0.2 * rand(0)) * totalSize;
        const sun2Size = totalSize - sun1Size;
        spiral2(rotate([w/2,h/2], [w/2 - h/sun2Size - h/100, h/2], rotation), h/sun1Size);
        spiral2(rotate([w/2,h/2], [w/2 + h/sun1Size + h/100, h/2], rotation), h/sun2Size);
        draw();
    }

    const planetColors = ["green", "blue", "orange", "red", "green", "purple"];

    let nextOrbit = h/4;
    for (let i = 0; i < 2 + rand(0) * 4; i++) {

        pen = "gray";
        circle([w/2, h/2], nextOrbit);
        draw();

        pen = planetColors[Math.floor(rand(0) * planetColors.length)];

        const planetRotation = 2 * Math.PI * rand(0);
        const planetPosition = rotate([w/2, h/2], [w/2 + nextOrbit, h/2], planetRotation);
        const planetRadius = h/80 + rand(0) * h/40
        spiral2(planetPosition, planetRadius);
        draw();

        // maybe a second planet on the same orbit
        if (rand(0) > 0.8) {
            spiral2(rotate([w/2, h/2], [w/2 + nextOrbit, h/2], 2 * Math.PI * rand(0)), h/80 + rand(0) * h/40);
            draw();
        }

        // maybe a moon
        if (rand(0) > 0.6) {
            pen = "gray";
            circle(planetPosition, 2 * planetRadius);
            draw();

            pen = "silver";
            spiral2(rotate(planetPosition, [planetPosition[0] + 2 * planetRadius, planetPosition[1]], 2 * Math.PI * rand(0)), h/100 + rand(0) * h/200);
            draw();
        }

        nextOrbit += h/40 + rand(0) * h/10;
    }

    // outside orbits are pseudo-ellipses
    for (let i = 0; i < rand(0) * 3; i++) {
        pen = "gray";
        const rMin = nextOrbit;
        const rMax = nextOrbit * (1 + rand(0) * 0.4);
        fakeEllipse([w/2,h/2], rMin, rMax);
        draw();

        pen = planetColors[Math.floor(rand(0) * planetColors.length)];
        spiral2([w/2+rMax, h/2], h/30);
        draw();

        nextOrbit += h/40 + rand(0) * h/10;
    }
</script>
</body>
</html>
